///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef GSL_UTIL_H
#define GSL_UTIL_H

#include <gsl/gsl_common> // Central compiler and external dependencies
#include <gsl/gsl_assert> // for Expects

#if defined(_MSC_VER)

#if _MSC_VER < 1910
#pragma push_macro("GSL_CONSTEXPR")
#define GSL_CONSTEXPR /*GSL_CONSTEXPR*/
#endif                          // _MSC_VER < 1910
#endif                          // _MSC_VER

namespace gsl
{
//
// GSL.util: utilities
//

// index type for all container indexes/subscripts/sizes
using index = std::ptrdiff_t;

// final_action allows you to ensure something gets run at the end of a scope
template <class F>
class final_action
{
public:
    explicit final_action(F f) noexcept : f_(std::move(f)) {}

    final_action(final_action&& other) noexcept : f_(std::move(other.f_)), invoke_(other.invoke_)
    {
        other.invoke_ = false;
    }

    final_action(const final_action&) = delete;
    final_action& operator=(const final_action&) = delete;
    final_action& operator=(final_action&&) = delete;

    ~final_action() noexcept
    {
        if (invoke_) f_();
    }

private:
    F f_;
    bool invoke_ {true};
};

// finally() - convenience function to generate a final_action
template <class F>

final_action<F> finally(const F& f) noexcept
{
    return final_action<F>(f);
}

template <class F>
final_action<F> finally(F&& f) noexcept
{
    return final_action<F>(std::forward<F>(f));
}

// narrow_cast(): a searchable way to do narrowing casts of values
template <class T, class U>
GSL_CONSTEXPR T narrow_cast(U&& u) noexcept
{
    return static_cast<T>(std::forward<U>(u));
}

struct narrowing_error : public std::exception
{
};

namespace details
{
    template <typename T, typename U, bool> class NarrowCornerCase;

    template <typename T, typename U> 
    class NarrowCornerCase <T, U, false>
    {
    public:
        static bool Test(T t, U u)
        {
            // T is not the same sign as U
            return ((t < T(0)) != (u < U(0)));
        }
    };

    template <typename T, typename U>
    class NarrowCornerCase <T, U, true>
    {
    public:
        static bool Test(T, U)
        {
            // T is the same sign, so there is never a problem
            return false;
        }
    };

}

// narrow() : a checked version of narrow_cast() that throws if the cast changed the value
template <typename T, typename U>
T narrow(U u)
{
    T t = narrow_cast<T>(u);
    if (static_cast<U>(t) != u) gsl::details::throw_exception(narrowing_error());

    if(details::NarrowCornerCase<T, U, (std::is_signed<T>::value == std::is_signed<U>::value) >::Test(t, u))
        gsl::details::throw_exception(narrowing_error());

    return t;
}

//
// at() - Bounds-checked way of accessing builtin arrays, std::array, std::vector
//
template <class T, std::size_t N>
GSL_CONSTEXPR T& at(T (&arr)[N], const index i)
{
    Expects(i >= 0 && i < narrow_cast<index>(N));
    return arr[static_cast<std::size_t>(i)];
}

template <class Cont>
GSL_CONSTEXPR auto at(Cont& cont, const index i) -> decltype(cont[cont.size()])
{
    Expects(i >= 0 && i < narrow_cast<index>(cont.size()));
    using size_type = decltype(cont.size());
    return cont[static_cast<size_type>(i)];
}

template <class T>
GSL_CONSTEXPR T at(const std::initializer_list<T> cont, const index i)
{
    Expects(i >= 0 && i < narrow_cast<index>(cont.size()));
    return *(cont.begin() + i);
}

} // namespace gsl

#if defined(_MSC_VER)
#if _MSC_VER < 1910
#undef GSL_CONSTEXPR
#pragma pop_macro("GSL_CONSTEXPR")

#endif // _MSC_VER < 1910

#endif // _MSC_VER

#endif // GSL_UTIL_H
